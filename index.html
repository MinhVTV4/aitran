<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phiên dịch AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        html, body {
            height: 100%;
            overflow: hidden;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
        }
        #conversationView::-webkit-scrollbar, #historyPanel::-webkit-scrollbar, #settingsPanel::-webkit-scrollbar {
            width: 6px;
        }
        #conversationView::-webkit-scrollbar-track, #historyPanel::-webkit-scrollbar-track, #settingsPanel::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        #conversationView::-webkit-scrollbar-thumb, #historyPanel::-webkit-scrollbar-thumb, #settingsPanel::-webkit-scrollbar-thumb {
            background: #d1d5db;
            border-radius: 6px;
        }
        #conversationView::-webkit-scrollbar-thumb:hover, #historyPanel::-webkit-scrollbar-thumb:hover, #settingsPanel::-webkit-scrollbar-thumb:hover {
            background: #a5a9af;
        }
        
        .mic-button {
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 14px 0 rgba(0, 118, 255, 0.39);
        }
        .mic-button:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 6px 20px 0 rgba(0, 118, 255, 0.23);
        }
        .mic-button.recording {
            transform: scale(1.1);
            background-color: #ef4444;
            box-shadow: 0 0 0 10px rgba(239, 68, 68, 0.4);
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.5); }
            70% { box-shadow: 0 0 0 12px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }

        .bubble {
            max-width: 75%;
            padding: 10px 15px;
            border-radius: 18px;
            word-wrap: break-word;
        }
        .user-bubble {
            background-color: #2563eb;
            color: white;
            border-bottom-right-radius: 4px;
        }
        .assistant-bubble {
            background-color: #e2e8f0;
            color: #1e293b;
            border-bottom-left-radius: 4px;
        }
        .info-bubble {
            background-color: #fef9c3;
            color: #713f12;
            text-align: center;
            font-style: italic;
            max-width: 90%;
            margin: 4px auto;
        }
        .error-bubble {
            background-color: #fee2e2;
            color: #991b1b;
            text-align: center;
            max-width: 90%;
            margin: 4px auto;
        }
        .gemini-feature-bubble {
            background-color: #e0f2fe; /* Light blue background */
            color: #0c4a6e;
            border-bottom-left-radius: 4px;
            border: 1px solid #bae6fd;
            margin-top: -8px; /* Slightly overlap previous bubble */
            max-width: 72%; /* Slightly smaller */
            align-self: flex-start;
        }

        .bubble-actions {
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }
        .bubble:hover .bubble-actions {
            opacity: 1;
        }
        
        .speaker-btn.muted i {
            color: #9ca3af; /* Gray color for muted icon */
        }

        .message-box {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(17, 24, 39, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.5s, transform 0.5s;
            pointer-events: none;
        }
        .message-box.show {
            opacity: 1;
            transform: translate(-50%, -10px);
        }
        .spinner {
            display: inline-block;
            width: 1em;
            height: 1em;
            border: 2px solid currentColor;
            border-right-color: transparent;
            border-radius: 50%;
            animation: spinner-border .75s linear infinite;
            vertical-align: -0.125em;
        }
        @keyframes spinner-border {
            to { transform: rotate(360deg); }
        }
        .listening-indicator span {
            display: inline-block;
            width: 8px;
            height: 8px;
            margin: 0 2px;
            background-color: currentColor;
            border-radius: 50%;
            opacity: 0.7;
            animation: listening-pulse 1.4s infinite ease-in-out both;
        }
        .listening-indicator span:nth-child(1) { animation-delay: -0.32s; }
        .listening-indicator span:nth-child(2) { animation-delay: -0.16s; }
        @keyframes listening-pulse {
            0%, 80%, 100% { transform: scale(0.6); opacity: 0.5;}
            40% { transform: scale(1.0); opacity: 1;}
        }

        .switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 28px; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #2563eb; }
        input:checked + .slider:before { transform: translateX(22px); }

        #textInput {
            resize: none;
            overflow-y: hidden;
            max-height: 120px;
        }
        
        .suggestion-btn {
            background-color: #f1f5f9;
            border: 1px solid #e2e8f0;
            color: #334155;
            transition: background-color 0.2s;
        }
        .suggestion-btn:hover {
            background-color: #e2e8f0;
        }
    </style>
</head>
<body class="p-0 sm:p-4">

    <div id="appContainer" class="w-full h-full max-w-2xl mx-auto flex flex-col bg-white sm:rounded-2xl sm:shadow-2xl overflow-hidden">
        <header class="flex-shrink-0 flex justify-between items-center p-3 border-b border-gray-200">
            <div class="text-left">
                 <h1 class="text-lg sm:text-xl font-bold text-gray-800">Phiên dịch AI</h1>
                 <p id="mic-instruction" class="text-xs text-gray-500">Nhấn & Giữ Micro để nói</p>
            </div>
            <div class="flex items-center space-x-1">
                 <button id="newChatBtn" class="p-2 rounded-full hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500" title="Cuộc trò chuyện mới" aria-label="Cuộc trò chuyện mới">
                     <i class="fas fa-plus-square text-lg text-gray-600"></i>
                 </button>
                 <button id="settingsToggleBtn" class="p-2 rounded-full hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500" title="Cài đặt" aria-label="Cài đặt">
                     <i class="fas fa-cog text-lg text-gray-600"></i>
                 </button>
                 <button id="authToggleBtn" class="p-2 rounded-full hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500" title="Tài khoản" aria-label="Tài khoản">
                     <i class="fas fa-user-circle text-lg text-gray-600"></i>
                 </button>
                  <button id="historyToggleBtn" class="p-2 rounded-full hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500" title="Lịch sử dịch" aria-label="Lịch sử dịch">
                     <i class="fas fa-history text-lg text-gray-600"></i>
                 </button>
            </div>
        </header>

        <!-- Main Content Area -->
        <div class="flex-grow flex flex-col overflow-hidden relative">
            <div id="conversationView" class="flex-grow p-4 space-y-4 overflow-y-auto">
                <!-- Bubbles will be added here dynamically -->
            </div>
            
            <div id="suggestionContainer" class="flex-shrink-0 p-2 flex gap-2 overflow-x-auto">
                <!-- Suggestion buttons will be added here -->
            </div>

            <div id="permission-overlay" class="absolute inset-0 bg-white/90 backdrop-blur-sm z-30 flex-col items-center justify-center text-center p-6 rounded-lg" style="display: none;">
                <i class="fas fa-microphone-slash text-5xl text-red-500 mb-4"></i>
                <h3 class="text-2xl font-bold text-gray-800 mb-2">Cần Quyền Truy Cập Micro</h3>
                <p class="text-gray-600">Ứng dụng này cần quyền truy cập vào micro của bạn để nhận dạng giọng nói.</p>
                <p id="ios-pwa-instruction" class="mt-4 text-sm text-blue-700 bg-blue-100 p-2 rounded-lg" style="display: none;">
                    <strong>Mẹo cho người dùng iOS:</strong> Để cấp quyền, vui lòng mở ứng dụng này trực tiếp trên trình duyệt Safari.
                </p>
            </div>

            <div id="settingsPanel" class="absolute top-0 right-0 w-full max-w-sm h-full bg-white/80 backdrop-blur-sm p-6 rounded-lg shadow-lg transform translate-x-full transition-transform duration-300 ease-in-out z-20 overflow-y-auto">
                 <button id="closeSettingsBtn" class="absolute top-3 right-4 text-gray-500 hover:text-gray-800 text-2xl" aria-label="Đóng cài đặt">&times;</button>
                 <h3 class="text-lg font-semibold text-gray-700 mb-6 text-center">Cài đặt</h3>
                 <div class="space-y-6">
                     <div class="flex items-center justify-between">
                        <label for="smartSuggestionsToggle" class="text-gray-700">Gợi ý thông minh</label>
                        <label class="switch"><input type="checkbox" id="smartSuggestionsToggle"><span class="slider"></span></label>
                    </div>
                    <div>
                        <label for="voiceSelect" class="text-gray-700 font-medium">Giọng đọc (ưu tiên)</label>
                        <select id="voiceSelect" class="mt-2 bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5">
                            <option>Đang tải giọng đọc...</option>
                        </select>
                         <p class="text-xs text-gray-500 mt-1">Sẽ tự động chọn giọng phù hợp nếu không có lựa chọn.</p>
                    </div>
                    <div>
                        <label class="text-gray-700 font-medium">Chế độ ghi âm</label>
                        <div class="mt-2 space-y-2">
                            <div class="flex items-center">
                                <input id="mode-hold" type="radio" name="recordingMode" value="hold" class="focus:ring-blue-500 h-4 w-4 text-blue-600 border-gray-300">
                                <label for="mode-hold" class="ml-3 block text-sm text-gray-700">Nhấn và Giữ</label>
                            </div>
                            <div class="flex items-center">
                                <input id="mode-toggle" type="radio" name="recordingMode" value="toggle" class="focus:ring-blue-500 h-4 w-4 text-blue-600 border-gray-300">
                                <label for="mode-toggle" class="ml-3 block text-sm text-gray-700">Nhấn để Bật/Tắt</label>
                            </div>
                             <div class="flex items-center">
                                <input id="mode-continuous" type="radio" name="recordingMode" value="continuous" class="focus:ring-blue-500 h-4 w-4 text-blue-600 border-gray-300">
                                <label for="mode-continuous" class="ml-3 block text-sm text-gray-700">Chế độ Trò chuyện</label>
                            </div>
                        </div>
                    </div>
                     <div id="bilingualToggleContainer" class="flex items-center justify-between p-3 bg-blue-50 rounded-lg transition-opacity duration-300">
                        <div>
                            <label for="bilingualToggle" class="font-medium text-blue-800">Hội thoại song ngữ</label>
                            <p class="text-xs text-blue-600">Tự động đổi chiều dịch sau mỗi lượt nói.</p>
                        </div>
                        <label class="switch">
                            <input type="checkbox" id="bilingualToggle">
                            <span class="slider"></span>
                        </label>
                    </div>
                 </div>
            </div>

            <div id="authPanel" class="absolute top-0 right-0 w-full max-w-sm h-full bg-white/80 backdrop-blur-sm p-6 rounded-lg shadow-lg transform translate-x-full transition-transform duration-300 ease-in-out z-20">
                 <button id="closeAuthBtn" class="absolute top-3 right-4 text-gray-500 hover:text-gray-800 text-2xl" aria-label="Đóng tài khoản">&times;</button>
                 <h3 class="text-lg font-semibold text-gray-700 mb-4 text-center">Tài Khoản</h3>
                 <div id="authForm" style="display: block;">
                    <input type="email" id="emailInput" class="w-full px-3 py-2 border rounded-md mb-2" placeholder="Email" autocomplete="email">
                    <input type="password" id="passwordInput" class="w-full px-3 py-2 border rounded-md mb-2" placeholder="Mật khẩu" autocomplete="current-password">
                    <div class="flex justify-center space-x-2">
                        <button id="registerButton" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">Đăng Ký</button>
                        <button id="loginButton" class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700">Đăng Nhập</button>
                    </div>
                </div>
                <div id="userInfo" style="display: none;" class="text-center">
                    <p id="userEmail" class="text-sm text-gray-700 mb-3"></p>
                    <button id="logoutButton" class="px-4 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600">Đăng Xuất</button>
                </div>
                 <div id="authStatus" class="text-xs text-gray-500 mt-4 text-center">Chưa đăng nhập.</div>
            </div>

             <div id="historyPanel" class="absolute top-0 right-0 w-full max-w-sm h-full bg-white/80 backdrop-blur-sm p-6 rounded-lg shadow-lg transform translate-x-full transition-transform duration-300 ease-in-out z-20 overflow-y-auto">
                 <button id="closeHistoryBtn" class="absolute top-3 right-4 text-gray-500 hover:text-gray-800 text-2xl" aria-label="Đóng lịch sử">&times;</button>
                 <h3 class="text-lg font-semibold text-gray-700 mb-4 text-center">Lịch Sử Trò Chuyện</h3>
                 <div id="sessionHistory" class="space-y-2"></div>
             </div>
        </div>

        <!-- Controls Area -->
        <div class="flex-shrink-0 px-1 sm:px-4 pt-3 border-t border-gray-200">
             <div class="flex items-center justify-between mb-3">
                <div class="flex items-center flex-1">
                    <select id="sourceLangSelect" class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5">
                        <option value="vi-VN" selected>Tiếng Việt</option>
                        <option value="en-US">English</option>
                        <option value="es-ES">Español</option>
                        <option value="fr-FR">Français</option>
                        <option value="de-DE">Deutsch</option>
                        <option value="it-IT">Italiano</option>
                        <option value="ja-JP">日本語</option>
                        <option value="ko-KR">한국어</option>
                        <option value="ru-RU">Русский</option>
                        <option value="hi-IN">हिन्दी</option>
                        <option value="zh-CN">中文 (普通话)</option>
                        <option value="pt-BR">Português</option>
                    </select>
                    <button id="sourceLangSpeakerBtn" class="speaker-btn p-2 rounded-full hover:bg-gray-200 ml-1" title="Bật/Tắt đọc ngôn ngữ này">
                        <i class="fas fa-volume-up text-gray-600"></i>
                    </button>
                </div>
                <button id="swapLangButton" class="p-3 mx-1 rounded-full hover:bg-gray-200" title="Đảo chiều ngôn ngữ" aria-label="Đảo chiều ngôn ngữ">
                    <i class="fas fa-exchange-alt text-lg text-gray-600"></i>
                </button>
                <div class="flex items-center flex-1">
                    <select id="targetLangSelect" class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5">
                        <option value="en" selected>English</option>
                        <option value="vi">Tiếng Việt</option>
                        <option value="es">Español</option>
                        <option value="fr">Français</option>
                        <option value="de">Deutsch</option>
                        <option value="it">Italiano</option>
                        <option value="ja">日本語</option>
                        <option value="ko">한국어</option>
                        <option value="ru">Русский</option>
                        <option value="hi">हिन्दी</option>
                        <option value="zh">中文 (普通话)</option>
                        <option value="pt">Português</option>
                    </select>
                    <button id="targetLangSpeakerBtn" class="speaker-btn p-2 rounded-full hover:bg-gray-200 ml-1" title="Bật/Tắt đọc ngôn ngữ này">
                        <i class="fas fa-volume-up text-gray-600"></i>
                    </button>
                </div>
             </div>
            
            <div class="flex items-end space-x-2 pb-2">
                <button id="micButton" class="mic-button w-12 h-12 flex-shrink-0 bg-blue-600 text-white rounded-full flex items-center justify-center" title="Nói để dịch" aria-label="Nói để dịch">
                    <i class="fas fa-microphone-alt text-xl"></i>
                </button>
                <textarea id="textInput" rows="1" class="flex-grow p-2.5 bg-gray-100 border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500" placeholder="Nhập văn bản để dịch..."></textarea>
                <button id="sendButton" class="w-12 h-12 flex-shrink-0 bg-green-500 text-white rounded-full flex items-center justify-center hover:bg-green-600" title="Gửi" aria-label="Gửi văn bản dịch">
                     <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>
    </div>

    <div id="messageBox" class="message-box"></div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
        import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-auth.js";
        import { initializeFirestore, memoryLocalCache, collection, addDoc, query, where, orderBy, onSnapshot, serverTimestamp, limit, getDocs, doc } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js";
        import { getAI, getGenerativeModel } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-ai.js";

        // DOM Elements
        const appContainer = document.getElementById('appContainer');
        const micButton = document.getElementById('micButton');
        const micInstruction = document.getElementById('mic-instruction');
        const conversationView = document.getElementById('conversationView');
        const messageBox = document.getElementById('messageBox');
        const sourceLangSelect = document.getElementById('sourceLangSelect');
        const targetLangSelect = document.getElementById('targetLangSelect');
        const sourceLangSpeakerBtn = document.getElementById('sourceLangSpeakerBtn');
        const targetLangSpeakerBtn = document.getElementById('targetLangSpeakerBtn');
        const swapLangButton = document.getElementById('swapLangButton');
        const permissionOverlay = document.getElementById('permission-overlay');
        const textInput = document.getElementById('textInput');
        const sendButton = document.getElementById('sendButton');
        const newChatBtn = document.getElementById('newChatBtn');
        const suggestionContainer = document.getElementById('suggestionContainer');
        
        // Panel & Settings Elements
        const settingsToggleBtn = document.getElementById('settingsToggleBtn');
        const settingsPanel = document.getElementById('settingsPanel');
        const closeSettingsBtn = document.getElementById('closeSettingsBtn');
        const smartSuggestionsToggle = document.getElementById('smartSuggestionsToggle');
        const voiceSelect = document.getElementById('voiceSelect');
        const recordingModeRadios = document.querySelectorAll('input[name="recordingMode"]');
        const bilingualToggle = document.getElementById('bilingualToggle');
        const bilingualToggleContainer = document.getElementById('bilingualToggleContainer');
        const authToggleBtn = document.getElementById('authToggleBtn');
        const authPanel = document.getElementById('authPanel');
        const closeAuthBtn = document.getElementById('closeAuthBtn');
        const historyToggleBtn = document.getElementById('historyToggleBtn');
        const historyPanel = document.getElementById('historyPanel');
        const closeHistoryBtn = document.getElementById('closeHistoryBtn');
        const sessionHistoryDiv = document.getElementById('sessionHistory');

        // Auth Elements
        const emailInput = document.getElementById('emailInput');
        const passwordInput = document.getElementById('passwordInput');
        const registerButton = document.getElementById('registerButton');
        const loginButton = document.getElementById('loginButton');
        const logoutButton = document.getElementById('logoutButton');
        const authForm = document.getElementById('authForm');
        const userInfo = document.getElementById('userInfo');
        const userEmailDisplay = document.getElementById('userEmail');
        const authStatus = document.getElementById('authStatus');

        const firebaseConfig = {
            apiKey: "AIzaSyA59vtuIdiQ-EOF5-XsUTk21RIpWWZLK7A",
            authDomain: "trans-98f6e.firebaseapp.com",
            projectId: "trans-98f6e",
            storageBucket: "trans-98f6e.appspot.com",
            messagingSenderId: "898356985543",
            appId: "1:898356985543:web:854fa33b475c79b95448e2"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = initializeFirestore(app, {
            localCache: memoryLocalCache()
        });
        
        let generativeModel;
        try {
            const firebaseAIService = getAI(app);
            generativeModel = getGenerativeModel(firebaseAIService, { model: "gemini-1.5-flash" });
        } catch (error) {
            console.error("Lỗi khởi tạo Firebase AI Logic:", error);
            showUIMessage("Lỗi khởi tạo dịch vụ AI.", 5000);
            micButton.disabled = true;
        }

        // --- State Management ---
        const AppState = {
            recognition: null,
            isRecording: false,
            isContinuousModeActive: false,
            currentListenBubbleId: null,
            finalTranscriptForBubble: '',
            unsubscribeSessions: null,
            currentSessionId: null,
            chatSession: null,
            voicesLoaded: false,
            voicesReadyResolve: null,
            appSettings: {
                recordingMode: 'hold',
                bilingualMode: false,
                smartSuggestions: true,
                voiceURI: null,
                speakStates: {}
            }
        };
        const voicesReadyPromise = new Promise(resolve => { AppState.voicesReadyResolve = resolve; });
        
        const languageMap = {
            "vi-VN": { name: "Tiếng Việt", ttsName: "vi-VN", geminiName: "Vietnamese", ttsPrefix: "vi" },
            "en-US": { name: "English", ttsName: "en-US", geminiName: "English", ttsPrefix: "en" },
            "es-ES": { name: "Español", ttsName: "es-ES", geminiName: "Spanish", ttsPrefix: "es" },
            "fr-FR": { name: "Français", ttsName: "fr-FR", geminiName: "French", ttsPrefix: "fr" },
            "de-DE": { name: "Deutsch", ttsName: "de-DE", geminiName: "German", ttsPrefix: "de" },
            "it-IT": { name: "Italiano", ttsName: "it-IT", geminiName: "Italian", ttsPrefix: "it" },
            "ja-JP": { name: "日本語", ttsName: "ja-JP", geminiName: "Japanese", ttsPrefix: "ja" },
            "ko-KR": { name: "한국어", ttsName: "ko-KR", geminiName: "Korean", ttsPrefix: "ko" },
            "ru-RU": { name: "Русский", ttsName: "ru-RU", geminiName: "Russian", ttsPrefix: "ru" },
            "hi-IN": { name: "हिन्दी", ttsName: "hi-IN", geminiName: "Hindi", ttsPrefix: "hi" },
            "zh-CN": { name: "中文 (普通话)", ttsName: "zh-CN", geminiName: "Mandarin Chinese", ttsPrefix: "zh" },
            "pt-BR": { name: "Português", ttsName: "pt-BR", geminiName: "Portuguese", ttsPrefix: "pt" },
            "vi": { name: "Tiếng Việt", ttsName: "vi-VN", geminiName: "Vietnamese", ttsPrefix: "vi" },
            "en": { name: "English", ttsName: "en-US", geminiName: "English", ttsPrefix: "en" },
            "es": { name: "Español", ttsName: "es-ES", geminiName: "Spanish", ttsPrefix: "es" },
            "fr": { name: "Français", ttsName: "fr-FR", geminiName: "French", ttsPrefix: "fr" },
            "de": { name: "Deutsch", ttsName: "de-DE", geminiName: "German", ttsPrefix: "de" },
            "it": { name: "Italiano", ttsName: "it-IT", geminiName: "Italian", ttsPrefix: "it" },
            "ja": { name: "日本語", ttsName: "ja-JP", geminiName: "Japanese", ttsPrefix: "ja" },
            "ko": { name: "한국어", ttsName: "ko-KR", geminiName: "Korean", ttsPrefix: "ko" },
            "ru": { name: "Русский", ttsName: "ru-RU", geminiName: "Russian", ttsPrefix: "ru" },
            "hi": { name: "हिन्दी", ttsName: "hi-IN", geminiName: "Hindi", ttsPrefix: "hi" },
            "zh": { name: "中文 (普通话)", ttsName: "zh-CN", geminiName: "Mandarin Chinese", ttsPrefix: "zh" },
            "pt": { name: "Português", ttsName: "pt-BR", geminiName: "Portuguese", ttsPrefix: "pt" }
        };

        // --- UI Functions ---
        function showUIMessage(message, duration = 3000) {
            messageBox.textContent = message;
            messageBox.classList.add('show');
            setTimeout(() => messageBox.classList.remove('show'), duration);
        }

        function scrollToBottom() {
            conversationView.scrollTop = conversationView.scrollHeight;
        }

        function createBubble(text, type, lang, originalTextForGemini = '') {
            const bubbleId = `bubble-${Date.now()}-${Math.random()}`;
            const bubbleWrapper = document.createElement('div');
            let bubbleClass = '';
            
            switch(type) {
                case 'user': bubbleWrapper.className = 'flex justify-end'; bubbleClass = 'user-bubble'; break;
                case 'assistant': bubbleWrapper.className = 'flex justify-start'; bubbleClass = 'assistant-bubble'; break;
                case 'info': bubbleWrapper.className = 'flex justify-center'; bubbleClass = 'info-bubble'; break;
                case 'error': bubbleWrapper.className = 'flex justify-center'; bubbleClass = 'error-bubble'; break;
                case 'gemini-feature': bubbleWrapper.className = 'flex justify-start'; bubbleClass = 'gemini-feature-bubble'; break;
            }
            
            const bubble = document.createElement('div');
            bubble.id = bubbleId;
            bubble.className = `bubble ${bubbleClass}`;

            if (type === 'assistant') {
                bubble.dataset.translatedText = text;
                bubble.dataset.originalText = originalTextForGemini;
                bubble.dataset.sourceLang = sourceLangSelect.value;
                bubble.dataset.targetLang = targetLangSelect.value;
            }

            let actionsHTML = '';
            if (type === 'assistant') {
                 actionsHTML = `
                    <button class="tts-button p-1 hover:bg-black/10 rounded-full" title="Nghe lại" aria-label="Nghe lại"><i class="fas fa-volume-up text-xs"></i></button>
                    <button class="copy-button p-1 hover:bg-black/10 rounded-full" title="Sao chép" aria-label="Sao chép"><i class="fas fa-copy text-xs"></i></button>
                    <button class="refine-button p-1 hover:bg-black/10 rounded-full" title="✨ Tự nhiên hóa" aria-label="Tự nhiên hóa câu dịch"><i class="fas fa-magic-wand-sparkles text-xs text-purple-500"></i></button>
                    <button class="explain-button p-1 hover:bg-black/10 rounded-full" title="? Giải thích" aria-label="Giải thích bản dịch"><i class="fas fa-question-circle text-xs text-blue-500"></i></button>
                 `;
            } else if (type === 'user') {
                actionsHTML = `<button class="copy-button p-1 hover:bg-black/10 rounded-full" title="Sao chép" aria-label="Sao chép"><i class="fas fa-copy text-xs"></i></button>`;
            }


            bubble.innerHTML = `<div class="text-content">${text}</div>${actionsHTML ? `<div class="bubble-actions flex items-center justify-end space-x-1 mt-1">${actionsHTML}</div>` : ''}`;
            
            bubbleWrapper.appendChild(bubble);
            conversationView.appendChild(bubbleWrapper);
            scrollToBottom();
            return bubbleId;
        }

        // --- Core Logic ---
        async function startNewChatSession(isInitialLoad = false) {
            if (!generativeModel) return;

            if (auth.currentUser) {
                try {
                    const sessionRef = await addDoc(collection(db, `users/${auth.currentUser.uid}/sessions`), {
                        title: `Hội thoại lúc ${new Date().toLocaleString('vi-VN')}`,
                        createdAt: serverTimestamp()
                    });
                    AppState.currentSessionId = sessionRef.id;
                    console.log("New session created with ID:", AppState.currentSessionId);
                } catch(e) {
                    console.error("Error creating new session:", e);
                    showUIMessage("Lỗi tạo phiên mới.");
                    return;
                }
            } else {
                AppState.currentSessionId = `local-${Date.now()}`;
            }
            
            conversationView.innerHTML = '';
            createBubble(
                '<p class="font-medium">Chào bạn!</p><p class="text-sm text-gray-600 mt-1">Bắt đầu một cuộc trò chuyện mới.</p>',
                'assistant'
            );

            AppState.chatSession = generativeModel.startChat({
                history: []
            });
            clearSuggestions();
        }

        function initializeSpeechRecognition() {
            const SpeechRecognition = window.webkitSpeechRecognition || window.SpeechRecognition;
            if (!SpeechRecognition) {
                showUIMessage("Trình duyệt không hỗ trợ nhận dạng giọng nói.", 5000);
                micButton.disabled = true;
                return;
            }
            AppState.recognition = new SpeechRecognition();
            AppState.recognition.continuous = false; 
            AppState.recognition.interimResults = true;
            AppState.recognition.lang = sourceLangSelect.value;
            
            AppState.recognition.onstart = () => {
                AppState.isRecording = true;
                AppState.finalTranscriptForBubble = ''; 
                AppState.currentListenBubbleId = createBubble('<div class="listening-indicator"><span></span><span></span><span></span></div>', 'user');
                micButton.classList.add('recording');
                micButton.querySelector('i').className = 'fas fa-stop text-xl';
                clearSuggestions();
            };
            
            AppState.recognition.onresult = (event) => {
                let interimTranscript = '';
                let finalChunk = '';
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) finalChunk += event.results[i][0].transcript;
                    else interimTranscript += event.results[i][0].transcript;
                }
                AppState.finalTranscriptForBubble += finalChunk;
                const listeningBubble = document.getElementById(AppState.currentListenBubbleId);
                if (listeningBubble) {
                    listeningBubble.querySelector('.text-content').textContent = AppState.finalTranscriptForBubble + interimTranscript;
                    scrollToBottom();
                }
            };
            
            AppState.recognition.onerror = (event) => {
                const listeningBubble = document.getElementById(AppState.currentListenBubbleId);
                if (listeningBubble) listeningBubble.parentElement.remove();
                AppState.currentListenBubbleId = null;

                if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
                    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                    const isInStandaloneMode = ('standalone' in window.navigator) && (window.navigator.standalone);
                    if (isIOS && isInStandaloneMode) {
                        document.getElementById('ios-pwa-instruction').style.display = 'block';
                    }
                    permissionOverlay.style.display = 'flex';
                    AppState.isContinuousModeActive = false; 
                } else if (event.error === 'no-speech') {
                    console.log("No speech detected.");
                } else {
                    console.warn("Speech Recognition Warning:", event.error);
                }
                
                AppState.isRecording = false;
            };

            AppState.recognition.onend = async () => {
                AppState.isRecording = false;
                const transcriptToProcess = AppState.finalTranscriptForBubble.trim();
                const listeningBubble = document.getElementById(AppState.currentListenBubbleId);
                let processedSuccessfully = false;

                if (listeningBubble) {
                     if (transcriptToProcess) {
                        listeningBubble.querySelector('.text-content').textContent = transcriptToProcess;
                        await translateAndDisplay(transcriptToProcess);
                        processedSuccessfully = true;
                     } else listeningBubble.parentElement.remove();
                }
                AppState.currentListenBubbleId = null;

                if (AppState.appSettings.recordingMode === 'continuous' && AppState.isContinuousModeActive) {
                    startNextTurn(processedSuccessfully);
                } else {
                    AppState.isContinuousModeActive = false;
                    micButton.classList.remove('recording');
                    micButton.querySelector('i').className = 'fas fa-microphone-alt text-xl';
                }
            };
        }
        
        function populateVoiceList() {
            const voices = speechSynthesis.getVoices();
            if (voices.length === 0 && !AppState.voicesLoaded) return; 

            const uniqueLangs = Object.values(
                Object.values(languageMap).reduce((acc, lang) => {
                    if (lang.ttsPrefix) acc[lang.ttsPrefix] = lang;
                    return acc;
                }, {})
            );

            voiceSelect.innerHTML = '';

            uniqueLangs.forEach(lang => {
                const optgroup = document.createElement('optgroup');
                optgroup.label = `Giọng ${lang.name}`;

                const filteredVoices = voices.filter(voice => voice.lang.startsWith(lang.ttsPrefix));

                if (filteredVoices.length > 0) {
                    filteredVoices.forEach(voice => {
                        const option = document.createElement('option');
                        option.value = voice.voiceURI;
                        option.textContent = voice.name;
                        optgroup.appendChild(option);
                    });
                    voiceSelect.appendChild(optgroup);
                }
            });
            
            if (AppState.appSettings.voiceURI && voiceSelect.querySelector(`option[value="${AppState.appSettings.voiceURI}"]`)) {
                voiceSelect.value = AppState.appSettings.voiceURI;
            }

            if (!AppState.voicesLoaded) {
                AppState.voicesLoaded = true;
                AppState.voicesReadyResolve();
            }
        }
        
        async function speakText(text, langCode) {
            await voicesReadyPromise;
            return new Promise((resolve) => {
                if (!text || !langCode || !window.speechSynthesis) {
                    resolve();
                    return;
                }
                
                speechSynthesis.cancel();
                const utterance = new SpeechSynthesisUtterance(text);
                const voices = speechSynthesis.getVoices();
                const targetLangPrefix = languageMap[langCode]?.ttsPrefix;

                let voiceToUse = null;

                const preferredVoice = voices.find(v => v.voiceURI === AppState.appSettings.voiceURI);
                if (preferredVoice && preferredVoice.lang.startsWith(targetLangPrefix)) {
                    voiceToUse = preferredVoice;
                }

                if (!voiceToUse) {
                    voiceToUse = voices.find(v => v.lang.startsWith(targetLangPrefix));
                }
                
                if (voiceToUse) {
                    utterance.voice = voiceToUse;
                }
                
                utterance.lang = languageMap[langCode]?.ttsName || langCode;
                
                utterance.onend = () => { resolve(); };
                utterance.onerror = (e) => { 
                    console.error("Speech synthesis error:", e); 
                    resolve();
                };
                speechSynthesis.speak(utterance);
            });
        }

        async function translateAndDisplay(text) {
            if (!AppState.chatSession) {
                showUIMessage("Phiên trò chuyện chưa sẵn sàng. Vui lòng thử lại.", 4000);
                return;
            }
            clearSuggestions();

            const assistantBubbleId = createBubble('<span class="spinner"></span>', 'assistant', targetLangSelect.value, text);
            
            try {
                const sourceLangName = languageMap[sourceLangSelect.value].geminiName;
                const targetLangName = languageMap[targetLangSelect.value].geminiName;
                
                const contextualPrompt = `Considering the previous conversation turns, provide a natural and accurate translation of the user's latest message from ${sourceLangName} to ${targetLangName}. Output ONLY the translated text, with no extra explanations or quotation marks. The user's message is: "${text}"`;

                const result = await AppState.chatSession.sendMessage(contextualPrompt);
                const response = await result.response;
                const translatedText = response.text().trim();

                const assistantBubble = document.getElementById(assistantBubbleId);
                if (assistantBubble) {
                    const bubbleContent = assistantBubble.querySelector('.text-content');
                    bubbleContent.textContent = translatedText;
                    assistantBubble.dataset.translatedText = translatedText;
                    assistantBubble.dataset.originalText = text;
                    assistantBubble.dataset.sourceLang = sourceLangSelect.value;
                    assistantBubble.dataset.targetLang = targetLangSelect.value;

                    if (AppState.appSettings.speakStates[targetLangSelect.value] && translatedText) {
                        await speakText(translatedText, targetLangSelect.value);
                    }

                    if (auth.currentUser && text && translatedText) {
                        saveMessageToSession(text, translatedText, sourceLangSelect.value, targetLangSelect.value);
                    }
                    if (AppState.appSettings.smartSuggestions) {
                        fetchAndDisplaySuggestions();
                    }
                }

            } catch (error) {
                console.error("Translation error:", error);
                const failedBubble = document.getElementById(assistantBubbleId);
                if (failedBubble && failedBubble.parentElement) {
                    failedBubble.parentElement.remove();
                }

                let errorMessage = "Đã có lỗi với AI, phiên dịch đã được làm mới.";
                if (error.message) {
                    if (error.message.includes('429') || error.message.toLowerCase().includes('quota')) {
                        errorMessage = "Lỗi: Đã vượt quá hạn ngạch (quota) sử dụng API. Vui lòng kiểm tra lại gói cước trên Google AI Studio hoặc Firebase.";
                    } else if (error.message.toLowerCase().includes('api key') || error.message.includes('403')) {
                        errorMessage = "Lỗi: API Key không hợp lệ hoặc chưa được kích hoạt cho dự án này. Vui lòng kiểm tra lại cài đặt Firebase.";
                    } else {
                        errorMessage = `Lỗi từ AI: ${error.message}.`;
                    }
                }
                
                startNewChatSession();
                createBubble(errorMessage, 'error');
            }
        }
        
        function startNextTurn(processedLastTurn) {
            if (AppState.appSettings.bilingualMode && processedLastTurn) {
                swapLanguages();
            }
            createBubble(`Bây giờ đang nghe bằng ${languageMap[sourceLangSelect.value].name}...`, 'info');
            setTimeout(() => {
                if (AppState.isContinuousModeActive && !AppState.isRecording) {
                    try {
                        AppState.recognition.start();
                    } catch (e) {
                        console.error("Error restarting recognition:", e);
                    }
                }
            }, 500);
        }


        async function saveMessageToSession(original, translated, sourceLang, targetLang) {
             if (!auth.currentUser || !AppState.currentSessionId) return;
             try {
                const messagesCol = collection(db, `users/${auth.currentUser.uid}/sessions/${AppState.currentSessionId}/messages`);
                await addDoc(messagesCol, {
                    originalText: original, translatedText: translated,
                    sourceLang: sourceLang, targetLang: targetLang, createdAt: serverTimestamp()
                });
            } catch (e) { console.error("Error saving message to session: ", e); }
        }

        async function speakSequentially(textsToSpeak) {
            await voicesReadyPromise;
            speechSynthesis.cancel();
            for (const item of textsToSpeak) {
                await new Promise(resolve => {
                    const utterance = new SpeechSynthesisUtterance(item.text);
                    const voices = speechSynthesis.getVoices();
                    const targetLangPrefix = languageMap[item.lang]?.ttsPrefix;
                    let voiceToUse = voices.find(v => v.lang.startsWith(targetLangPrefix));
                    if(voiceToUse) utterance.voice = voiceToUse;

                    utterance.lang = languageMap[item.lang]?.ttsName || item.lang;
                    utterance.onend = resolve;
                    utterance.onerror = (e) => {
                        console.error("Sequential speech error", e);
                        resolve(); 
                    };
                    speechSynthesis.speak(utterance);
                });
            }
        }

        async function handleRefine(targetBubble) {
            const { translatedText, targetLang } = targetBubble.dataset;
            if (!translatedText || !targetLang) return;

            const targetLangName = languageMap[targetLang]?.geminiName;
            const prompt = `Rephrase the following ${targetLangName} text to sound more natural and fluent, like a native speaker would say it. Output ONLY the rephrased text, without any additional explanations or quotation marks. The text is: "${translatedText}"`;
            
            const featureBubbleId = createBubble(`✨ <span class="spinner ml-2"></span>`, 'gemini-feature');

            try {
                const result = await generativeModel.generateContent(prompt);
                const response = await result.response;
                const refinedText = response.text().trim();
                
                const featureBubble = document.getElementById(featureBubbleId);
                if (featureBubble) {
                    featureBubble.querySelector('.text-content').innerHTML = `✨ <strong>Tự nhiên hơn:</strong> ${refinedText}`;
                    if (AppState.appSettings.speakStates[targetLang]) {
                        await speakText(refinedText, targetLang);
                    }
                }
            } catch(e) {
                console.error("Refine error:", e);
                const featureBubble = document.getElementById(featureBubbleId);
                if(featureBubble) featureBubble.querySelector('.text-content').textContent = 'Lỗi khi tinh chỉnh câu văn.';
            }
        }
        
        async function handleExplain(targetBubble) {
            const { originalText, translatedText, sourceLang, targetLang } = targetBubble.dataset;
            if (!originalText || !translatedText || !sourceLang || !targetLang) return;

            const sourceLangName = languageMap[sourceLang]?.geminiName;
            const targetLangName = languageMap[targetLang]?.geminiName;
            const explanationLangName = languageMap[sourceLangSelect.value]?.geminiName;

            const prompt = `Explain the translation from the ${sourceLangName} phrase "${originalText}" to the ${targetLangName} phrase "${translatedText}". Focus on any nuances, idiomatic expressions, or cultural context. Provide the explanation in ${explanationLangName}.`;

            const featureBubbleId = createBubble(`? <span class="spinner ml-2"></span>`, 'gemini-feature');

            try {
                const result = await generativeModel.generateContent(prompt);
                const response = await result.response;
                const explanationText = response.text().trim();

                const featureBubble = document.getElementById(featureBubbleId);
                if (featureBubble) {
                     featureBubble.querySelector('.text-content').innerHTML = `? <strong>Giải thích:</strong> ${explanationText}`;
                }
            } catch(e) {
                console.error("Explain error:", e);
                const featureBubble = document.getElementById(featureBubbleId);
                if(featureBubble) featureBubble.querySelector('.text-content').textContent = 'Lỗi khi lấy giải thích.';
            }
        }
        
        async function fetchAndDisplaySuggestions() {
            clearSuggestions();
            if (!AppState.chatSession || !generativeModel) return;

            const suggestionLang = AppState.appSettings.bilingualMode ? sourceLangSelect.value : targetLangSelect.value;
            const suggestionLangName = languageMap[suggestionLang]?.geminiName;
            if (!suggestionLangName) return;

            const prompt = `Based on the last turn of the conversation, suggest 3 short, relevant, and natural replies or questions in ${suggestionLangName}. Format the output as a JSON array of strings, like this: ["suggestion 1", "suggestion 2", "suggestion 3"]. Do not include any other text or markdown.`;

            try {
                const result = await AppState.chatSession.sendMessage(prompt);
                const response = await result.response;
                let text = response.text().trim().replace(/```json|```/g, '');
                
                const suggestions = JSON.parse(text);

                if (Array.isArray(suggestions) && suggestions.length > 0) {
                    suggestions.slice(0, 3).forEach(suggestion => {
                        const btn = document.createElement('button');
                        btn.className = 'suggestion-btn px-3 py-1.5 rounded-full text-sm whitespace-nowrap';
                        btn.textContent = suggestion;
                        btn.onclick = () => {
                            handleSendFromInput(suggestion);
                        };
                        suggestionContainer.appendChild(btn);
                    });
                }
            } catch (e) {
                console.error("Error fetching suggestions:", e);
            }
        }

        function clearSuggestions() {
            suggestionContainer.innerHTML = '';
        }

        // --- Event Listeners ---
        function handleSendFromInput(textOverride) {
            const text = (typeof textOverride === 'string') ? textOverride : textInput.value.trim();
            if (text) {
                createBubble(text, 'user', sourceLangSelect.value);
                translateAndDisplay(text);
                if (typeof textOverride !== 'string') {
                    textInput.value = '';
                    textInput.style.height = 'auto';
                }
            }
        }
        sendButton.addEventListener('click', () => handleSendFromInput());
        textInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSendFromInput(); }});
        textInput.addEventListener('input', () => { textInput.style.height = 'auto'; textInput.style.height = `${textInput.scrollHeight}px`; });

        micButton.addEventListener('click', (e) => {
            e.preventDefault();
            if (micButton.disabled) return;
            switch (AppState.appSettings.recordingMode) {
                case 'toggle': AppState.isRecording ? AppState.recognition.stop() : AppState.recognition.start(); break;
                case 'continuous':
                    if (AppState.isContinuousModeActive) {
                        AppState.isContinuousModeActive = false; 
                        if (AppState.isRecording) AppState.recognition.stop();
                    } else {
                        AppState.isContinuousModeActive = true; 
                        if (!AppState.isRecording) AppState.recognition.start();
                    }
                    break;
            }
        });
        micButton.addEventListener('mousedown', (e) => { if (AppState.appSettings.recordingMode === 'hold') { e.preventDefault(); if (!AppState.isRecording && !micButton.disabled) AppState.recognition.start(); } });
        micButton.addEventListener('mouseup', (e) => { if (AppState.appSettings.recordingMode === 'hold') { e.preventDefault(); if (AppState.isRecording) AppState.recognition.stop(); } });
        micButton.addEventListener('touchstart', (e) => { if (AppState.appSettings.recordingMode === 'hold') { e.preventDefault(); if (!AppState.isRecording && !micButton.disabled) AppState.recognition.start(); } }, { passive: false });
        micButton.addEventListener('touchend', (e) => { if (AppState.appSettings.recordingMode === 'hold') { e.preventDefault(); if (AppState.isRecording) AppState.recognition.stop(); } });

        function swapLanguages() {
            const oldSourceValue = sourceLangSelect.value; 
            const oldTargetValue = targetLangSelect.value;
            
            const newSourcePrefix = languageMap[oldTargetValue]?.ttsPrefix;
            const newSourceOption = Array.from(sourceLangSelect.options).find(opt => 
                languageMap[opt.value]?.ttsPrefix === newSourcePrefix
            );

            const newTargetPrefix = languageMap[oldSourceValue]?.ttsPrefix;
            
            if (newSourceOption && newTargetPrefix) {
                sourceLangSelect.value = newSourceOption.value;
                targetLangSelect.value = newTargetPrefix;
                if (AppState.recognition) {
                    AppState.recognition.lang = sourceLangSelect.value;
                }
            } else {
                console.error("Could not find matching languages to swap.", { oldSourceValue, oldTargetValue });
            }
            updateSpeakerIcons();
        }

        swapLangButton.addEventListener('click', () => { 
            swapLanguages(); 
            showUIMessage("Đã đảo chiều ngôn ngữ. Bắt đầu hội thoại mới.", 2500);
            startNewChatSession();
        });
        
        function handleLanguageChange() {
            if (AppState.recognition) { 
                AppState.recognition.lang = sourceLangSelect.value; 
            }
            updateSpeakerIcons();
        }
        sourceLangSelect.addEventListener('change', handleLanguageChange);
        targetLangSelect.addEventListener('change', handleLanguageChange);
        
        voiceSelect.addEventListener('change', (e) => {
            AppState.appSettings.voiceURI = e.target.value;
            saveSettings();
        });

        newChatBtn.addEventListener('click', () => startNewChatSession());

        conversationView.addEventListener('click', (e) => {
            const ttsButton = e.target.closest('.tts-button');
            const copyButton = e.target.closest('.copy-button');
            const refineButton = e.target.closest('.refine-button');
            const explainButton = e.target.closest('.explain-button');
            
            if (ttsButton) speakText(ttsButton.closest('.bubble').querySelector('.text-content').textContent, ttsButton.closest('.assistant-bubble').dataset.targetLang);
            if (copyButton) navigator.clipboard.writeText(copyButton.closest('.bubble').querySelector('.text-content').textContent).then(() => showUIMessage("Đã sao chép!", 1500));
            if (refineButton) handleRefine(refineButton.closest('.assistant-bubble'));
            if (explainButton) handleExplain(explainButton.closest('.assistant-bubble'));
        });
        
        sessionHistoryDiv.addEventListener('click', async (e) => {
            const historyItem = e.target.closest('.session-item');
            if (!historyItem || !auth.currentUser) return;
            
            const sessionId = historyItem.dataset.sessionId;
            const messagesRef = collection(db, `users/${auth.currentUser.uid}/sessions/${sessionId}/messages`);
            const q = query(messagesRef, orderBy("createdAt", "asc"));

            conversationView.innerHTML = '<div>Đang tải cuộc trò chuyện...</div>';
            closeAllPanels();

            const querySnapshot = await getDocs(q);
            conversationView.innerHTML = '';
            querySnapshot.forEach(doc => {
                const msg = doc.data();
                createBubble(msg.originalText, 'user', msg.sourceLang);
                createBubble(msg.translatedText, 'assistant', msg.targetLang, msg.originalText);
            });
            AppState.currentSessionId = sessionId;
        });

        // --- Settings & Panels ---
        function saveSettings() { localStorage.setItem('translatorAppSettings', JSON.stringify(AppState.appSettings)); }
        function loadSettings() {
            const savedSettings = localStorage.getItem('translatorAppSettings');
            if (savedSettings) {
                 AppState.appSettings = { ...AppState.appSettings, ...JSON.parse(savedSettings) };
            }
            
            Object.keys(languageMap).forEach(langCode => {
                if (AppState.appSettings.speakStates[langCode] === undefined) {
                    AppState.appSettings.speakStates[langCode] = langCode.startsWith('en');
                }
            });

            smartSuggestionsToggle.checked = AppState.appSettings.smartSuggestions;
            document.querySelector(`input[name="recordingMode"][value="${AppState.appSettings.recordingMode}"]`).checked = true;
            updateMicInstruction();
            updateBilingualToggleState();
            updateSpeakerIcons();
        }
        function updateMicInstruction() {
            if (AppState.appSettings.recordingMode === 'hold') micInstruction.textContent = "Nhấn & Giữ Micro để nói";
            else if (AppState.appSettings.recordingMode === 'toggle') micInstruction.textContent = "Nhấn Micro để Bật/Tắt";
            else micInstruction.textContent = "Nhấn Micro để bắt đầu/dừng Trò chuyện";
        }
        function updateBilingualToggleState() {
            const isContinuous = AppState.appSettings.recordingMode === 'continuous';
            bilingualToggleContainer.style.opacity = isContinuous ? '1' : '0.5';
            bilingualToggleContainer.style.pointerEvents = isContinuous ? 'auto' : 'none';
            bilingualToggle.disabled = !isContinuous;
            if (!isContinuous) {
                bilingualToggle.checked = false;
                AppState.appSettings.bilingualMode = false;
                saveSettings();
            }
        }
        
        function updateSpeakerIcons() {
            const sourceLang = sourceLangSelect.value;
            const targetLang = targetLangSelect.value;
            
            const sourceIcon = sourceLangSpeakerBtn.querySelector('i');
            const targetIcon = targetLangSpeakerBtn.querySelector('i');

            if (AppState.appSettings.speakStates[sourceLang]) {
                sourceIcon.className = 'fas fa-volume-up text-blue-600';
                sourceLangSpeakerBtn.classList.remove('muted');
            } else {
                sourceIcon.className = 'fas fa-volume-mute text-gray-400';
                sourceLangSpeakerBtn.classList.add('muted');
            }

            if (AppState.appSettings.speakStates[targetLang]) {
                targetIcon.className = 'fas fa-volume-up text-blue-600';
                targetLangSpeakerBtn.classList.remove('muted');
            } else {
                targetIcon.className = 'fas fa-volume-mute text-gray-400';
                targetLangSpeakerBtn.classList.add('muted');
            }
        }

        sourceLangSpeakerBtn.addEventListener('click', () => {
            const lang = sourceLangSelect.value;
            AppState.appSettings.speakStates[lang] = !AppState.appSettings.speakStates[lang];
            saveSettings();
            updateSpeakerIcons();
        });

        targetLangSpeakerBtn.addEventListener('click', () => {
            const lang = targetLangSelect.value;
            AppState.appSettings.speakStates[lang] = !AppState.appSettings.speakStates[lang];
            saveSettings();
            updateSpeakerIcons();
        });
        
        smartSuggestionsToggle.addEventListener('change', e => { AppState.appSettings.smartSuggestions = e.target.checked; saveSettings(); });
        bilingualToggle.addEventListener('change', (e) => { AppState.appSettings.bilingualMode = e.target.checked; saveSettings(); });
        recordingModeRadios.forEach(radio => radio.addEventListener('change', (e) => {
            if (e.target.checked) {
                if (AppState.isContinuousModeActive) { 
                    AppState.isContinuousModeActive = false;
                    if (AppState.isRecording) AppState.recognition.stop();
                }
                AppState.appSettings.recordingMode = e.target.value;
                updateMicInstruction();
                updateBilingualToggleState();
                saveSettings();
            }
        }));

        function closeAllPanels() {
            settingsPanel.classList.add('translate-x-full');
            authPanel.classList.add('translate-x-full');
            historyPanel.classList.add('translate-x-full');
        }
        settingsToggleBtn.addEventListener('click', () => { const isHidden = settingsPanel.classList.contains('translate-x-full'); closeAllPanels(); if (isHidden) settingsPanel.classList.remove('translate-x-full'); });
        authToggleBtn.addEventListener('click', () => { const isHidden = authPanel.classList.contains('translate-x-full'); closeAllPanels(); if (isHidden) authPanel.classList.remove('translate-x-full'); });
        historyToggleBtn.addEventListener('click', () => { const isHidden = historyPanel.classList.contains('translate-x-full'); closeAllPanels(); if (isHidden) historyPanel.classList.remove('translate-x-full'); });
        closeSettingsBtn.addEventListener('click', () => settingsPanel.classList.add('translate-x-full'));
        closeAuthBtn.addEventListener('click', () => authPanel.classList.add('translate-x-full'));
        closeHistoryBtn.addEventListener('click', () => historyPanel.classList.add('translate-x-full'));
        
        // --- Auth & History Logic ---
        onAuthStateChanged(auth, (user) => {
            if (user) {
                authForm.style.display = 'none'; userInfo.style.display = 'block';
                userEmailDisplay.textContent = `Chào, ${user.email}`; authStatus.textContent = `Đã đăng nhập`;
                loadSessionHistory(user.uid);
            } else {
                authForm.style.display = 'block'; userInfo.style.display = 'none';
                userEmailDisplay.textContent = ''; authStatus.textContent = 'Chưa đăng nhập.';
                sessionHistoryDiv.innerHTML = '<p class="text-center text-gray-500 text-sm">Đăng nhập để xem lịch sử.</p>';
                if (AppState.unsubscribeSessions) AppState.unsubscribeSessions();
            }
        });
        registerButton.addEventListener('click', async () => { const { value: email } = emailInput; const { value: password } = passwordInput; if (!email || !password) return showUIMessage("Vui lòng nhập email và mật khẩu."); try { await createUserWithEmailAndPassword(auth, email, password); showUIMessage("Đăng ký thành công!"); emailInput.value = ''; passwordInput.value = ''; } catch (error) { showUIMessage(`Lỗi đăng ký: ${error.code}`, 5000); } });
        loginButton.addEventListener('click', async () => { const { value: email } = emailInput; const { value: password } = passwordInput; if (!email || !password) return showUIMessage("Vui lòng nhập email và mật khẩu."); try { await signInWithEmailAndPassword(auth, email, password); showUIMessage("Đăng nhập thành công!"); emailInput.value = ''; passwordInput.value = ''; authPanel.classList.add('translate-x-full'); } catch (error) { showUIMessage(`Lỗi đăng nhập: ${error.code}`, 5000); } });
        logoutButton.addEventListener('click', async () => { try { await signOut(auth); showUIMessage("Đã đăng xuất."); } catch (error) { showUIMessage("Lỗi đăng xuất.", 5000); } });

        function loadSessionHistory(userId) {
            if (AppState.unsubscribeSessions) AppState.unsubscribeSessions();
            const q = query(collection(db, `users/${userId}/sessions`), orderBy("createdAt", "desc"), limit(10)); // <-- UPDATED with limit(10)
            AppState.unsubscribeSessions = onSnapshot(q, (querySnapshot) => {
                sessionHistoryDiv.innerHTML = querySnapshot.empty ? '<p class="text-center text-gray-500 text-sm">Chưa có lịch sử nào.</p>' : '';
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    const item = document.createElement('div');
                    item.className = 'session-item p-3 rounded-lg bg-gray-100 border border-gray-200 cursor-pointer hover:bg-gray-200';
                    item.dataset.sessionId = doc.id;
                    item.innerHTML = `<p class="text-sm font-medium text-gray-800 pointer-events-none">${data.title || 'Cuộc trò chuyện'}</p>
                                    <p class="text-xs text-gray-500 pointer-events-none">${new Date(data.createdAt?.seconds * 1000).toLocaleString('vi-VN')}</p>`;
                    sessionHistoryDiv.appendChild(item);
                });
            }, (error) => { console.error("Lỗi tải lịch sử phiên: ", error); sessionHistoryDiv.innerHTML = '<p class="text-center text-red-500 text-sm">Lỗi khi tải lịch sử.</p>'; });
        }
        
        // --- Initial Load ---
        function setAppHeight() {
            appContainer.style.height = `${window.innerHeight}px`;
        }
        window.addEventListener('resize', setAppHeight);
        setAppHeight();

        loadSettings();
        initializeSpeechRecognition();
        startNewChatSession(true);

        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = populateVoiceList;
        } else {
            setTimeout(populateVoiceList, 200);
        }

    </script>
</body>
</html>

